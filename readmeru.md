# Задание: CRUD API

## Описание

Ваша задача - реализовать простой CRUD API с использованием внутренней базы данных.

## Технические требования

- Задание может быть выполнено на Javascript или Typescript
- Разрешаются только следующие пакеты: `nodemon`, `dotenv`, `cross-env`, `typescript`, `ts-node`, `ts-node-dev`, `eslint` и его плагины, `webpack-cli`, `webpack` и его плагины, `prettier`, `uuid`, `@types/*` а также библиотеки, используемые для тестирования
- Используйте версию Node.js 20 LTS
- Предпочтительно использование асинхронного API всякий раз, когда это возможно

## Детали реализации

1. Реализованная конечная точка `api/users`:
  - **GET** `api/users` используется для получения всех пользователей
    - Сервер должен ответить `кодом статуса` **200** и всеми записями пользователей
  - **GET** `api/users/{userId}`
    - Сервер должен ответить `кодом статуса` **200** и записью с `id === userId`, если она существует
    - Сервер должен ответить `кодом статуса` **400** и соответствующим сообщением, если `userId` недействителен (не `uuid`)
    - Сервер должен ответить `кодом статуса` **404** и соответствующим сообщением, если запись с `id === userId` не существует
  - **POST** `api/users` используется для создания записи о новом пользователе и ее хранения в базе данных
    - Сервер должен ответить `кодом статуса` **201** и вновь созданной записью
    - Сервер должен ответить `кодом статуса` **400** и соответствующим сообщением, если тело запроса `body` не содержит **необходимые** поля
  - **PUT** `api/users/{userId}` используется для обновления данных существующего пользователя
    - Сервер должен ответить `кодом статуса` **200** и обновленной записью
    - Сервер должен ответить `кодом статуса` **400** и соответствующим сообщением, если `userId` недействителен (не `uuid`)
    - Сервер должен ответить `кодом статуса` **404** и соответствующим сообщением, если запись с `id === userId` не существует
  - **DELETE** `api/users/{userId}` используется для удаления существующего пользователя из базы данных
    - Сервер должен ответить `кодом статуса` **204**, если запись найдена и удалена
    - Сервер должен ответить `кодом статуса` **400** и соответствующим сообщением, если `userId` недействителен (не `uuid`)
    - Сервер должен ответить `кодом статуса` **404** и соответствующим сообщением, если запись с `id === userId` не существует
2. Пользователи хранятся как `объекты` со следующими свойствами:
  - `id` — уникальный идентификатор (`string`, `uuid`), генерируемый на стороне сервера
  - `username` — имя пользователя (`string`, **обязательное**)
  - `age` — возраст пользователя (`number`, **обязательное**)
  - `hobbies` — увлечения пользователя (`array` строк или пустой `array`, **обязательное**)
3. Запросы к несуществующим конечным точкам (например, `some-non/existing/resource`) должны быть обработаны (сервер должен ответить `кодом статуса` **404** и соответствующим сообщением)
4. Ошибки на сервере, возникающие во время обработки запроса, должны быть обработаны и обработаны корректно (сервер должен ответить `кодом статуса` **500** и соответствующим сообщением)
5. Значение `port`, на котором работает приложение, должно храниться в файле `.env`
6. Приложение должно работать в двух режимах (**development** и **production**):
  - Приложение запускается в режиме разработки с использованием `nodemon` или `ts-node-dev` (существует `npm` сценарий `start:dev`)
  - Приложение запускается в продакшен-режиме (существует `npm` сценарий `start:prod`, который запускает процесс сборки, а затем запускает связанный файл)
7. Для API могут быть проведены тесты (не менее **3** сценариев). Пример сценария теста:
  1. Получаем все записи с помощью `GET` запроса `api/users` (ожидается пустой массив)
  2. Создаем новый объект с помощью `POST` запроса `api/users` (ожидается ответ, содержащий вновь созданную запись)
  3. С помощью `GET` запроса `api/user/{userId}` пытаемся получить созданную запись по ее `id` (ожидается созданная запись)
  4. Пытаемся обновить созданную запись с помощью `PUT` запроса `api/users/{userId}` (ожидается ответ, содержащий обновленный объект с тем же `id`)
  5. С помощью `DELETE` запроса `api/users/{userId}` удаляем созданный объект по `id` (ожидается подтверждение успешного удаления)
  6. С помощью `GET` запроса `api/users/{userId}` пытаемся получить удаленный объект по `id` (ожидается ответ, что такого объекта нет)
8. Может быть реализовано горизонтальное масштабирование приложения, должен быть `npm` сценарий `start:multi`, который запускает несколько экземпляров вашего приложения с использованием Node.js `Cluster` API (равное числу доступных параллелизмов - 1 на хост-машине, каждый слушает порт PORT + n) с **балансировщиком нагрузки**, который распределяет запросы между ними (используя алгоритм Round-robin). Например: доступные параллелизмы равны 4, `PORT` равен 4000. При запуске `npm run start:multi` это работает следующим образом
- На `localhost:4000/api` балансировщик нагрузки слушает запросы
- На `localhost:4001/api`, `localhost:4002/api`, `localhost:4003/api` рабочие слушают запросы от балансировщика нагрузки
- Когда пользователь отправляет запрос на `localhost:4000/api`, балансировщик нагрузки отправляет этот запрос на `localhost:4001/api`, следующий пользовательский запрос отправляется на `localhost:4002/api` и т.д.
- После отправки запроса на `localhost:4003/api` балансировщик нагрузки начинает снова с первого рабочего (отправляет запрос на `localhost:4001/api`)
- Состояние базы данных должно быть согласовано между разными рабочими, например:
  1. Первый `POST` запрос, направленный на `localhost:4001/api` создает пользователя
  2. Второй `GET` запрос, направленный на `localhost:4002/api` должен вернуть созданного пользователя
  3. Третий `DELETE` запрос, направленный на `localhost:4003/api` удаляет созданного пользователя
  4. Четвертый `GET` запрос, направленный на `localhost:4001/api` должен вернуть **404** код статуса для созданного пользователя




# Оценка: CRUD API

## Базовый уровень

- **+10** Репозиторий с приложением содержит файл `Readme.md` с подробными инструкциями по установке, запуску и использованию приложения
- **+10** **GET** `api/users` реализован правильно
- **+10** **GET** `api/users/{userId}` реализован правильно
- **+10** **POST** `api/users` реализован правильно
- **+10** **PUT** `api/users/{userId}` реализован правильно
- **+10** **DELETE** `api/users/{userId}` реализован правильно
- **+6** Пользователи хранятся в форме, описанной в технических требованиях
- **+6** Значение `port`, на котором работает приложение, хранится в файле `.env`.

## Продвинутый уровень
- **+30** Задача реализована на Typescript
- **+10** Правильно реализована обработка запросов к несуществующим конечным точкам
- **+10** Ошибки на серверной стороне, возникающие при обработке запроса, должны быть обработаны и обработаны правильно
- **+10** Режим разработки: `npm` скрипт `start:dev` реализован правильно
- **+10** Производственный режим: `npm` скрипт `start:prod` реализован правильно

## Хакерский уровень
- **+30** Есть тесты для API (не менее **3** сценариев)
- **+50** Присутствует горизонтальное масштабирование приложения с **балансировщиком нагрузки**

## Штрафы

- **-95% от общего балла за задачу** любые внешние инструменты, кроме `nodemon`, `dotenv`, `cross-env`, `typescript`, `ts-node`, `ts-node-dev`, `eslint` и его плагинов, `webpack` и его плагинов, `prettier` и его плагинов, `uuid`, `@types/*` а также библиотеки, используемые для тестирования
- **-30% от общего балла за задачу** Коммиты после дедлайна (кроме коммитов, которые влияют только на Readme.md, .gitignore и пр.)
- **-20** Отсутствует PR или его описание некорректно
- **-20** Отсутствует отдельная ветка разработки
- **-20** Меньше 3 коммитов в ветке разработки, не считая коммитов, которые вносят изменения только в `Readme.md` или аналогичные файлы (`tsconfig.json`, `.gitignore`, `.prettierrc.json` и пр.)
